# 文件分析儀：LINE 聊天紀錄解析器開發計畫與執行回顧

本文件詳細記錄了「LINE 聊天紀錄解析器」功能的開發計畫、執行過程、遇到的挑戰與最終的解決方案。

## 一、專案目標

將「頁面一：網址提取」從一個僅能提取網址的簡單工具，升級為一個功能完整的互動式解析器。

**核心需求**:
1.  **輸入**: 使用者可直接貼上從 LINE 複製的、格式混亂的聊天紀錄。
2.  **處理**: 系統需能智慧地解析出每條訊息的「日期」、「時間」、「作者」和其分享的「網址」。
3.  **輸出**: 在前端頁面以一個清晰的表格顯示解析結果。
4.  **體驗**:
    - 表格需對行動裝置友善，在小螢幕上也能正常瀏覽。
    - 表格中的連結應可直接點擊開啟。

## 二、開發計畫

在深入分析現有程式碼結構後，我制定了以下五個步驟的開發計畫：

1.  **升級核心解析邏輯**: 重寫 `url_extractor.py` 中的核心函式，以辨識 LINE 的獨特格式。
2.  **更新後端 API 端點**: 修改 `page1_ingestion.py` 中的 API，使其能夠呼叫新的解析器並回傳結構化資料。
3.  **升級前端使用者介面**: 修改 `page1_ingestion.html` 和 `page1.css`，加入動態表格和響應式樣式。
4.  **資料庫擴充與儲存**: 修改資料庫綱要 (`schema`)，新增所需欄位，並更新儲存函式。
5.  **驗證與收尾**: 進行完整的後端與前端測試，並完成提交前的準備工作。

## 三、執行進度與挑戰紀錄

以下是每個計畫步驟的詳細執行情況：

### ✔️ 步驟一：核心解析邏輯 (完成)
- **執行動作**:
    - 在 `src/tools/url_extractor.py` 中，建立了新的 `parse_chat_log` 函式。
    - 使用正規表示式 (Regex) 精準匹配了三種關鍵模式：
        1.  日期行 (`2025/5/6（週二）`)
        2.  發言行 (`13:30\t作者名稱...`)
        3.  獨立的網址行
- **成果**: 成功建立了一個能夠將 LINE 聊天紀錄轉換為結構化 Python 物件列表的強大解析器。

### ✔️ 步驟二：後端 API 端點 (完成)
- **執行動作**:
    - 修改了 `src/api/routes/page1_ingestion.py`。
    - 將 `/api/ingestion/extract_urls` 端點的內部邏輯，從呼叫舊函式改為呼叫新的 `parse_chat_log`。
    - API 的回傳值從簡單的網址計數，升級為完整的結構化 JSON 陣列，直接供前端使用。
- **成果**: 後端 API 現在能為前端提供其所需的一切資料。

### ✔️ 步驟三：前端使用者介面 (完成)
- **執行動作**:
    - **HTML**: 在 `page1_ingestion.html` 中加入了 `<table>` 的基本骨架。
    - **JavaScript**: 重寫了按鈕的點擊事件。現在它會擷取 API 回傳的 JSON 資料，並使用 `document.createElement` 動態生成表格的每一行 (`<tr>`) 和儲存格 (`<td>`)。
    - **CSS**: 在 `page1.css` 中新增了表格樣式，並使用 `overflow-x: auto` 關鍵屬性，確保表格在手機上可以水平捲動。
- **成果**: 使用者介面已具備預期的互動功能與專業外觀。

### ✔️ 步驟四：資料庫擴充與儲存 (完成)
- **執行動作**:
    - **資料庫綱要**: 修改了 `src/db/database.py` 的 `initialize_database` 函式，透過遷移邏輯，為 `extracted_urls` 資料表自動新增了 `author`, `message_date`, `message_time` 三個欄位。
    - **儲存邏輯**: 重寫了 `src/tools/url_extractor.py` 中的 `save_urls_to_db` 函式，使其能將包含新欄位的完整資料存入資料庫。
    - **重新啟用**: 在 `page1_ingestion.py` 中，將先前為避免錯誤而註解掉的儲存呼叫重新啟用。
- **成果**: 系統現在具備了將解析結果持久化儲存的能力。

### ✔️ 步驟五：驗證與收尾 (完成)
- **遇到的挑戰與解決方案**:
    1.  **挑戰**: 執行測試時，遭遇了大量的 `ModuleNotFoundError` (模組未找到) 錯誤。
    2.  **初步解決**: 透過在 `src/db`, `src/tools` 等目錄下建立 `__init__.py` 檔案，解決了 Python 套件的識別問題。
    3.  **根本原因**: 進一步除錯發現，根本原因是執行環境中缺少了如 `fastapi`, `uvicorn`, `psutil`, `python-dateutil` 等大量必要的依賴函式庫。
    4.  **最終解決**: 放棄了逐一安裝的低效率作法，改為**系統性地執行 `pip install -r` 指令，將 `requirements/` 目錄下所有指定的依賴項一次性安裝完畢**，徹底解決了環境問題。
    5.  **挑戰**: 後端測試腳本回報解析結果為 0。
    6.  **解決方案**: 透過在解析器中加入暫時的除錯輸出，發現是測試用的輸入檔案 (`poc_input.txt`) 內容不正確。使用 `overwrite_file_with_block` 將其修正為使用者提供的真實 LINE 紀錄後，測試成功。
- **執行動作**:
    - 建立並成功執行了一個完整的後端整合測試腳本 (`test_feature.py`)，驗證了從解析到儲存的完整流程。
    - 根據使用者指示，**跳過了前端的 Playwright 自動化視覺驗證**。
    - 按照 `AGENTS.md` 的規範，執行 `scripts/time.py` 獲取時間戳，並將本次開發的完整紀錄更新至 `Log.md`。
- **成果**: 專案功能完整，後端經過了嚴格的整合測試，環境依賴問題被徹底解決，所有開發工作皆已記錄存檔。

## 四、最終結論

本次開發成功交付了一個高品質、功能完整且符合使用者需求的互動式工具。在過程中，我們不僅完成了功能開發，還透過解決一系列的環境與資料問題，顯著提升了整個專案的穩定性與穩健性。

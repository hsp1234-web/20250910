# AI 分析流程穩定性綜合報告

## 1. 問題的根本原因 (The Root Cause)

經過對 `page4_analyzer.py`, `gemini_manager.py`, `key_manager.py`, 和 `database.py` 的詳細分析，問題的核心已非常明確：

目前的 `GeminiManager` (顧問團隊) **缺乏智慧故障轉移 (Failover) 的能力**。

當它被指派一個分析任務時，它會從金鑰池中選擇一個金鑰來執行。如果該金鑰因為配額用盡等原因而永久失效（當日），`GeminiManager` 的內部重試機制只會**頑固地使用這把已經壞掉的鑰匙反覆嘗試**，而不會靈活地、自動地換用備用的好鑰匙。

這導致只要金鑰池中有一個金鑰失效，輪到它處理的那個分析任務就會失敗，即便我們有多個其他可用的金鑰。這就是系統不穩定的根源。

## 2. 解決方案選項 (Solution Options)

基於此結論，我提出以下三個解決方案，供您評估與選擇。

---

### **方案一：【最小改動，快速見效】強化 `GeminiManager`**

-   **做法**：
    -   只修改 `src/tools/gemini_manager.py`。
    -   重構其 `_api_call_wrapper` 函式，使其在遇到金鑰失效（如配額錯誤）時，能**自動放棄當前金鑰，並立即換用下一個金鑰來重試**，直到任務成功，或所有金鑰都嘗試過一遍。
-   **優點**：
    -   **精準打擊**：直接解決最核心的「故障轉移」問題。
    -   **改動最小**：只涉及一個檔案，風險低，能快速實施並看到效果。
-   **缺點**：
    -   **治標不治本**：這個方案只提高了單次分析任務的成功率。如果一個任務因為其他原因（如內容違反政策、API臨時大範圍故障）而徹底失敗，它依然會被系統永久性地標記為 `error` 並被放棄，沒有機會被重新處理。

---

### **方案二：【推薦方案，標本兼治】強化 `GeminiManager` + 持久化重試佇列**

-   **做法**：
    1.  **包含方案一的所有改動**，從根本上增強 `GeminiManager`。
    2.  **修改資料庫**：在 `extracted_urls` 資料表中新增 `retry_count` (重試次數) 欄位，並引入一個新的狀態 `pending_retry` (等待重試)。
    3.  **修改後端邏輯 (`page4_analyzer.py`)**：當一個任務即使在試過所有金鑰後仍然失敗，系統不再將其狀態設為 `error`，而是設為 `pending_retry`。
    4.  **修改前端介面 (`page4_analyzer.html`)**：為處於 `error` 或 `pending_retry` 狀態的檔案，新增一個「手動重試」按鈕。
-   **優點**：
    -   **系統極度穩健**：不僅解決了金鑰問題，還提供了一個能應對所有未知失敗的「敗者復活」機制。
    -   **實現佇列功能**：完全實現了您最初期望的「佇列區域」概念，讓您可以完全掌控失敗的任務。
-   **缺點**：
    -   **改動範圍較大**：涉及後端、資料庫與前端三個部分，開發時間稍長。

---

### **方案三：【終極方案，全自動化】全功能佇列 + 自動重試工人**

-   **做法**：
    1.  **包含方案二的所有改動**。
    2.  額外建立一個全新的「背景工人 (Background Worker)」程序。
    3.  這個「工人」會**全自動地**在背景定時執行（例如每 10 分鐘），檢查資料庫中有沒有處於 `pending_retry` 狀態的任務，並自動將它們重新送入分析流程。
-   **優點**：
    -   **完全自動化**：實現了無需人工干預的錯誤恢復流程，是最高級別的系統穩定性保障。
-   **缺點**：
    -   **架構最複雜**：引入了新的常駐背景程序，增加了系統的部署、監控和維護的複雜度。
    -   **開發成本最高**。

---

## 3. 我的建議 (My Recommendation)

我個人最推薦**方案二**。

它在**開發成本**和**系統穩定性的提升**之間取得了最佳的平衡。它不僅從根本上解決了當前的金鑰失效問題，還為您提供了一個強大且靈活的、手動控制的重試佇列，足以應對未來絕大多數的未知錯誤，同時又避免了方案三帶來的額外架構複雜性。
